// Implementation file for parser generated by fsyacc
module Parser
#nowarn "64";; // turn off warnings that type variables used in production annotations are instantiated to concrete type
open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Text.Parsing.ParseHelpers
# 1 "Parser.fsy"

#light "off"


# 11 "Parser.fs"
// This type is the type of tokens accepted by the parser
type token = 
  | BOX
  | RLABEL
  | LLABEL
  | LESSEQUAL
  | GREATEREQUAL
  | INEQUALITY
  | ASSIGNMENT
  | DOUBLESTAR
  | DOUBLEDOT
  | ARROW
  | PIPE
  | GREATER
  | EQUAL
  | LESS
  | SEMICOLON
  | COLON
  | SLASH
  | PERIOD
  | MINUS
  | COMMA
  | PLUS
  | STAR
  | RPAREN
  | LPAREN
  | QUOTE
  | AMPERSAND
  | NUMERIC_LITERAL of (string)
  | IDENTIFIER of (string)
  | EOF
  | XOR
  | WITH
  | WHILE
  | WHEN
  | USE
  | UNTIL
  | TYPE
  | THEN
  | TERMINATE
  | TASK
  | TAGGED
  | SYNCHRONIZED
  | SUBTYPE
  | SOME
  | SEPARATE
  | SELECT
  | REVERSE
  | RETURN
  | REQUEUE
  | RENAMES
  | REM
  | RECORD
  | RANGE
  | RAISE
  | PROTECTED
  | PROCEDURE
  | PRIVATE
  | PRAGMA
  | PACKAGE
  | OVERRIDING
  | OUT
  | OTHERS
  | OR
  | OF
  | NULL
  | NOT
  | NEW
  | MOD
  | LOOP
  | LIMITED
  | IS
  | INTERFACE
  | IN
  | IF
  | GOTO
  | GENERIC
  | FUNCTION
  | FOR
  | EXIT
  | EXCEPTION
  | ENTRY
  | END
  | ELSIF
  | ELSE
  | DO
  | DIGITS
  | DELTA
  | DELAY
  | DECLARE
  | CONSTANT
  | CASE
  | BODY
  | BEGIN
  | AT
  | ARRAY
  | AND
  | ALL
  | ALIASED
  | ACCESS
  | ACCEPT
  | ABSTRACT
  | ABS
  | ABORT
// This type is used to give symbolic names to token indexes, useful for error messages
type tokenId = 
    | TOKEN_BOX
    | TOKEN_RLABEL
    | TOKEN_LLABEL
    | TOKEN_LESSEQUAL
    | TOKEN_GREATEREQUAL
    | TOKEN_INEQUALITY
    | TOKEN_ASSIGNMENT
    | TOKEN_DOUBLESTAR
    | TOKEN_DOUBLEDOT
    | TOKEN_ARROW
    | TOKEN_PIPE
    | TOKEN_GREATER
    | TOKEN_EQUAL
    | TOKEN_LESS
    | TOKEN_SEMICOLON
    | TOKEN_COLON
    | TOKEN_SLASH
    | TOKEN_PERIOD
    | TOKEN_MINUS
    | TOKEN_COMMA
    | TOKEN_PLUS
    | TOKEN_STAR
    | TOKEN_RPAREN
    | TOKEN_LPAREN
    | TOKEN_QUOTE
    | TOKEN_AMPERSAND
    | TOKEN_NUMERIC_LITERAL
    | TOKEN_IDENTIFIER
    | TOKEN_EOF
    | TOKEN_XOR
    | TOKEN_WITH
    | TOKEN_WHILE
    | TOKEN_WHEN
    | TOKEN_USE
    | TOKEN_UNTIL
    | TOKEN_TYPE
    | TOKEN_THEN
    | TOKEN_TERMINATE
    | TOKEN_TASK
    | TOKEN_TAGGED
    | TOKEN_SYNCHRONIZED
    | TOKEN_SUBTYPE
    | TOKEN_SOME
    | TOKEN_SEPARATE
    | TOKEN_SELECT
    | TOKEN_REVERSE
    | TOKEN_RETURN
    | TOKEN_REQUEUE
    | TOKEN_RENAMES
    | TOKEN_REM
    | TOKEN_RECORD
    | TOKEN_RANGE
    | TOKEN_RAISE
    | TOKEN_PROTECTED
    | TOKEN_PROCEDURE
    | TOKEN_PRIVATE
    | TOKEN_PRAGMA
    | TOKEN_PACKAGE
    | TOKEN_OVERRIDING
    | TOKEN_OUT
    | TOKEN_OTHERS
    | TOKEN_OR
    | TOKEN_OF
    | TOKEN_NULL
    | TOKEN_NOT
    | TOKEN_NEW
    | TOKEN_MOD
    | TOKEN_LOOP
    | TOKEN_LIMITED
    | TOKEN_IS
    | TOKEN_INTERFACE
    | TOKEN_IN
    | TOKEN_IF
    | TOKEN_GOTO
    | TOKEN_GENERIC
    | TOKEN_FUNCTION
    | TOKEN_FOR
    | TOKEN_EXIT
    | TOKEN_EXCEPTION
    | TOKEN_ENTRY
    | TOKEN_END
    | TOKEN_ELSIF
    | TOKEN_ELSE
    | TOKEN_DO
    | TOKEN_DIGITS
    | TOKEN_DELTA
    | TOKEN_DELAY
    | TOKEN_DECLARE
    | TOKEN_CONSTANT
    | TOKEN_CASE
    | TOKEN_BODY
    | TOKEN_BEGIN
    | TOKEN_AT
    | TOKEN_ARRAY
    | TOKEN_AND
    | TOKEN_ALL
    | TOKEN_ALIASED
    | TOKEN_ACCESS
    | TOKEN_ACCEPT
    | TOKEN_ABSTRACT
    | TOKEN_ABS
    | TOKEN_ABORT
    | TOKEN_end_of_input
    | TOKEN_error
// This type is used to give symbolic names to token indexes, useful for error messages
type nonTerminalId = 
    | NONTERM__startstart
    | NONTERM_start

// This function maps tokens to integers indexes
let tagOfToken (t:token) = 
  match t with
  | BOX  -> 0 
  | RLABEL  -> 1 
  | LLABEL  -> 2 
  | LESSEQUAL  -> 3 
  | GREATEREQUAL  -> 4 
  | INEQUALITY  -> 5 
  | ASSIGNMENT  -> 6 
  | DOUBLESTAR  -> 7 
  | DOUBLEDOT  -> 8 
  | ARROW  -> 9 
  | PIPE  -> 10 
  | GREATER  -> 11 
  | EQUAL  -> 12 
  | LESS  -> 13 
  | SEMICOLON  -> 14 
  | COLON  -> 15 
  | SLASH  -> 16 
  | PERIOD  -> 17 
  | MINUS  -> 18 
  | COMMA  -> 19 
  | PLUS  -> 20 
  | STAR  -> 21 
  | RPAREN  -> 22 
  | LPAREN  -> 23 
  | QUOTE  -> 24 
  | AMPERSAND  -> 25 
  | NUMERIC_LITERAL _ -> 26 
  | IDENTIFIER _ -> 27 
  | EOF  -> 28 
  | XOR  -> 29 
  | WITH  -> 30 
  | WHILE  -> 31 
  | WHEN  -> 32 
  | USE  -> 33 
  | UNTIL  -> 34 
  | TYPE  -> 35 
  | THEN  -> 36 
  | TERMINATE  -> 37 
  | TASK  -> 38 
  | TAGGED  -> 39 
  | SYNCHRONIZED  -> 40 
  | SUBTYPE  -> 41 
  | SOME  -> 42 
  | SEPARATE  -> 43 
  | SELECT  -> 44 
  | REVERSE  -> 45 
  | RETURN  -> 46 
  | REQUEUE  -> 47 
  | RENAMES  -> 48 
  | REM  -> 49 
  | RECORD  -> 50 
  | RANGE  -> 51 
  | RAISE  -> 52 
  | PROTECTED  -> 53 
  | PROCEDURE  -> 54 
  | PRIVATE  -> 55 
  | PRAGMA  -> 56 
  | PACKAGE  -> 57 
  | OVERRIDING  -> 58 
  | OUT  -> 59 
  | OTHERS  -> 60 
  | OR  -> 61 
  | OF  -> 62 
  | NULL  -> 63 
  | NOT  -> 64 
  | NEW  -> 65 
  | MOD  -> 66 
  | LOOP  -> 67 
  | LIMITED  -> 68 
  | IS  -> 69 
  | INTERFACE  -> 70 
  | IN  -> 71 
  | IF  -> 72 
  | GOTO  -> 73 
  | GENERIC  -> 74 
  | FUNCTION  -> 75 
  | FOR  -> 76 
  | EXIT  -> 77 
  | EXCEPTION  -> 78 
  | ENTRY  -> 79 
  | END  -> 80 
  | ELSIF  -> 81 
  | ELSE  -> 82 
  | DO  -> 83 
  | DIGITS  -> 84 
  | DELTA  -> 85 
  | DELAY  -> 86 
  | DECLARE  -> 87 
  | CONSTANT  -> 88 
  | CASE  -> 89 
  | BODY  -> 90 
  | BEGIN  -> 91 
  | AT  -> 92 
  | ARRAY  -> 93 
  | AND  -> 94 
  | ALL  -> 95 
  | ALIASED  -> 96 
  | ACCESS  -> 97 
  | ACCEPT  -> 98 
  | ABSTRACT  -> 99 
  | ABS  -> 100 
  | ABORT  -> 101 

// This function maps integers indexes to symbolic token ids
let tokenTagToTokenId (tokenIdx:int) = 
  match tokenIdx with
  | 0 -> TOKEN_BOX 
  | 1 -> TOKEN_RLABEL 
  | 2 -> TOKEN_LLABEL 
  | 3 -> TOKEN_LESSEQUAL 
  | 4 -> TOKEN_GREATEREQUAL 
  | 5 -> TOKEN_INEQUALITY 
  | 6 -> TOKEN_ASSIGNMENT 
  | 7 -> TOKEN_DOUBLESTAR 
  | 8 -> TOKEN_DOUBLEDOT 
  | 9 -> TOKEN_ARROW 
  | 10 -> TOKEN_PIPE 
  | 11 -> TOKEN_GREATER 
  | 12 -> TOKEN_EQUAL 
  | 13 -> TOKEN_LESS 
  | 14 -> TOKEN_SEMICOLON 
  | 15 -> TOKEN_COLON 
  | 16 -> TOKEN_SLASH 
  | 17 -> TOKEN_PERIOD 
  | 18 -> TOKEN_MINUS 
  | 19 -> TOKEN_COMMA 
  | 20 -> TOKEN_PLUS 
  | 21 -> TOKEN_STAR 
  | 22 -> TOKEN_RPAREN 
  | 23 -> TOKEN_LPAREN 
  | 24 -> TOKEN_QUOTE 
  | 25 -> TOKEN_AMPERSAND 
  | 26 -> TOKEN_NUMERIC_LITERAL 
  | 27 -> TOKEN_IDENTIFIER 
  | 28 -> TOKEN_EOF 
  | 29 -> TOKEN_XOR 
  | 30 -> TOKEN_WITH 
  | 31 -> TOKEN_WHILE 
  | 32 -> TOKEN_WHEN 
  | 33 -> TOKEN_USE 
  | 34 -> TOKEN_UNTIL 
  | 35 -> TOKEN_TYPE 
  | 36 -> TOKEN_THEN 
  | 37 -> TOKEN_TERMINATE 
  | 38 -> TOKEN_TASK 
  | 39 -> TOKEN_TAGGED 
  | 40 -> TOKEN_SYNCHRONIZED 
  | 41 -> TOKEN_SUBTYPE 
  | 42 -> TOKEN_SOME 
  | 43 -> TOKEN_SEPARATE 
  | 44 -> TOKEN_SELECT 
  | 45 -> TOKEN_REVERSE 
  | 46 -> TOKEN_RETURN 
  | 47 -> TOKEN_REQUEUE 
  | 48 -> TOKEN_RENAMES 
  | 49 -> TOKEN_REM 
  | 50 -> TOKEN_RECORD 
  | 51 -> TOKEN_RANGE 
  | 52 -> TOKEN_RAISE 
  | 53 -> TOKEN_PROTECTED 
  | 54 -> TOKEN_PROCEDURE 
  | 55 -> TOKEN_PRIVATE 
  | 56 -> TOKEN_PRAGMA 
  | 57 -> TOKEN_PACKAGE 
  | 58 -> TOKEN_OVERRIDING 
  | 59 -> TOKEN_OUT 
  | 60 -> TOKEN_OTHERS 
  | 61 -> TOKEN_OR 
  | 62 -> TOKEN_OF 
  | 63 -> TOKEN_NULL 
  | 64 -> TOKEN_NOT 
  | 65 -> TOKEN_NEW 
  | 66 -> TOKEN_MOD 
  | 67 -> TOKEN_LOOP 
  | 68 -> TOKEN_LIMITED 
  | 69 -> TOKEN_IS 
  | 70 -> TOKEN_INTERFACE 
  | 71 -> TOKEN_IN 
  | 72 -> TOKEN_IF 
  | 73 -> TOKEN_GOTO 
  | 74 -> TOKEN_GENERIC 
  | 75 -> TOKEN_FUNCTION 
  | 76 -> TOKEN_FOR 
  | 77 -> TOKEN_EXIT 
  | 78 -> TOKEN_EXCEPTION 
  | 79 -> TOKEN_ENTRY 
  | 80 -> TOKEN_END 
  | 81 -> TOKEN_ELSIF 
  | 82 -> TOKEN_ELSE 
  | 83 -> TOKEN_DO 
  | 84 -> TOKEN_DIGITS 
  | 85 -> TOKEN_DELTA 
  | 86 -> TOKEN_DELAY 
  | 87 -> TOKEN_DECLARE 
  | 88 -> TOKEN_CONSTANT 
  | 89 -> TOKEN_CASE 
  | 90 -> TOKEN_BODY 
  | 91 -> TOKEN_BEGIN 
  | 92 -> TOKEN_AT 
  | 93 -> TOKEN_ARRAY 
  | 94 -> TOKEN_AND 
  | 95 -> TOKEN_ALL 
  | 96 -> TOKEN_ALIASED 
  | 97 -> TOKEN_ACCESS 
  | 98 -> TOKEN_ACCEPT 
  | 99 -> TOKEN_ABSTRACT 
  | 100 -> TOKEN_ABS 
  | 101 -> TOKEN_ABORT 
  | 104 -> TOKEN_end_of_input
  | 102 -> TOKEN_error
  | _ -> failwith "tokenTagToTokenId: bad token"

/// This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
let prodIdxToNonTerminal (prodIdx:int) = 
  match prodIdx with
    | 0 -> NONTERM__startstart 
    | 1 -> NONTERM_start 
    | _ -> failwith "prodIdxToNonTerminal: bad production index"

let _fsyacc_endOfInputTag = 104 
let _fsyacc_tagOfErrorTerminal = 102

// This function gets the name of a token as a string
let token_to_string (t:token) = 
  match t with 
  | BOX  -> "BOX" 
  | RLABEL  -> "RLABEL" 
  | LLABEL  -> "LLABEL" 
  | LESSEQUAL  -> "LESSEQUAL" 
  | GREATEREQUAL  -> "GREATEREQUAL" 
  | INEQUALITY  -> "INEQUALITY" 
  | ASSIGNMENT  -> "ASSIGNMENT" 
  | DOUBLESTAR  -> "DOUBLESTAR" 
  | DOUBLEDOT  -> "DOUBLEDOT" 
  | ARROW  -> "ARROW" 
  | PIPE  -> "PIPE" 
  | GREATER  -> "GREATER" 
  | EQUAL  -> "EQUAL" 
  | LESS  -> "LESS" 
  | SEMICOLON  -> "SEMICOLON" 
  | COLON  -> "COLON" 
  | SLASH  -> "SLASH" 
  | PERIOD  -> "PERIOD" 
  | MINUS  -> "MINUS" 
  | COMMA  -> "COMMA" 
  | PLUS  -> "PLUS" 
  | STAR  -> "STAR" 
  | RPAREN  -> "RPAREN" 
  | LPAREN  -> "LPAREN" 
  | QUOTE  -> "QUOTE" 
  | AMPERSAND  -> "AMPERSAND" 
  | NUMERIC_LITERAL _ -> "NUMERIC_LITERAL" 
  | IDENTIFIER _ -> "IDENTIFIER" 
  | EOF  -> "EOF" 
  | XOR  -> "XOR" 
  | WITH  -> "WITH" 
  | WHILE  -> "WHILE" 
  | WHEN  -> "WHEN" 
  | USE  -> "USE" 
  | UNTIL  -> "UNTIL" 
  | TYPE  -> "TYPE" 
  | THEN  -> "THEN" 
  | TERMINATE  -> "TERMINATE" 
  | TASK  -> "TASK" 
  | TAGGED  -> "TAGGED" 
  | SYNCHRONIZED  -> "SYNCHRONIZED" 
  | SUBTYPE  -> "SUBTYPE" 
  | SOME  -> "SOME" 
  | SEPARATE  -> "SEPARATE" 
  | SELECT  -> "SELECT" 
  | REVERSE  -> "REVERSE" 
  | RETURN  -> "RETURN" 
  | REQUEUE  -> "REQUEUE" 
  | RENAMES  -> "RENAMES" 
  | REM  -> "REM" 
  | RECORD  -> "RECORD" 
  | RANGE  -> "RANGE" 
  | RAISE  -> "RAISE" 
  | PROTECTED  -> "PROTECTED" 
  | PROCEDURE  -> "PROCEDURE" 
  | PRIVATE  -> "PRIVATE" 
  | PRAGMA  -> "PRAGMA" 
  | PACKAGE  -> "PACKAGE" 
  | OVERRIDING  -> "OVERRIDING" 
  | OUT  -> "OUT" 
  | OTHERS  -> "OTHERS" 
  | OR  -> "OR" 
  | OF  -> "OF" 
  | NULL  -> "NULL" 
  | NOT  -> "NOT" 
  | NEW  -> "NEW" 
  | MOD  -> "MOD" 
  | LOOP  -> "LOOP" 
  | LIMITED  -> "LIMITED" 
  | IS  -> "IS" 
  | INTERFACE  -> "INTERFACE" 
  | IN  -> "IN" 
  | IF  -> "IF" 
  | GOTO  -> "GOTO" 
  | GENERIC  -> "GENERIC" 
  | FUNCTION  -> "FUNCTION" 
  | FOR  -> "FOR" 
  | EXIT  -> "EXIT" 
  | EXCEPTION  -> "EXCEPTION" 
  | ENTRY  -> "ENTRY" 
  | END  -> "END" 
  | ELSIF  -> "ELSIF" 
  | ELSE  -> "ELSE" 
  | DO  -> "DO" 
  | DIGITS  -> "DIGITS" 
  | DELTA  -> "DELTA" 
  | DELAY  -> "DELAY" 
  | DECLARE  -> "DECLARE" 
  | CONSTANT  -> "CONSTANT" 
  | CASE  -> "CASE" 
  | BODY  -> "BODY" 
  | BEGIN  -> "BEGIN" 
  | AT  -> "AT" 
  | ARRAY  -> "ARRAY" 
  | AND  -> "AND" 
  | ALL  -> "ALL" 
  | ALIASED  -> "ALIASED" 
  | ACCESS  -> "ACCESS" 
  | ACCEPT  -> "ACCEPT" 
  | ABSTRACT  -> "ABSTRACT" 
  | ABS  -> "ABS" 
  | ABORT  -> "ABORT" 

// This function gets the data carried by a token as an object
let _fsyacc_dataOfToken (t:token) = 
  match t with 
  | BOX  -> (null : System.Object) 
  | RLABEL  -> (null : System.Object) 
  | LLABEL  -> (null : System.Object) 
  | LESSEQUAL  -> (null : System.Object) 
  | GREATEREQUAL  -> (null : System.Object) 
  | INEQUALITY  -> (null : System.Object) 
  | ASSIGNMENT  -> (null : System.Object) 
  | DOUBLESTAR  -> (null : System.Object) 
  | DOUBLEDOT  -> (null : System.Object) 
  | ARROW  -> (null : System.Object) 
  | PIPE  -> (null : System.Object) 
  | GREATER  -> (null : System.Object) 
  | EQUAL  -> (null : System.Object) 
  | LESS  -> (null : System.Object) 
  | SEMICOLON  -> (null : System.Object) 
  | COLON  -> (null : System.Object) 
  | SLASH  -> (null : System.Object) 
  | PERIOD  -> (null : System.Object) 
  | MINUS  -> (null : System.Object) 
  | COMMA  -> (null : System.Object) 
  | PLUS  -> (null : System.Object) 
  | STAR  -> (null : System.Object) 
  | RPAREN  -> (null : System.Object) 
  | LPAREN  -> (null : System.Object) 
  | QUOTE  -> (null : System.Object) 
  | AMPERSAND  -> (null : System.Object) 
  | NUMERIC_LITERAL _fsyacc_x -> Microsoft.FSharp.Core.Operators.box _fsyacc_x 
  | IDENTIFIER _fsyacc_x -> Microsoft.FSharp.Core.Operators.box _fsyacc_x 
  | EOF  -> (null : System.Object) 
  | XOR  -> (null : System.Object) 
  | WITH  -> (null : System.Object) 
  | WHILE  -> (null : System.Object) 
  | WHEN  -> (null : System.Object) 
  | USE  -> (null : System.Object) 
  | UNTIL  -> (null : System.Object) 
  | TYPE  -> (null : System.Object) 
  | THEN  -> (null : System.Object) 
  | TERMINATE  -> (null : System.Object) 
  | TASK  -> (null : System.Object) 
  | TAGGED  -> (null : System.Object) 
  | SYNCHRONIZED  -> (null : System.Object) 
  | SUBTYPE  -> (null : System.Object) 
  | SOME  -> (null : System.Object) 
  | SEPARATE  -> (null : System.Object) 
  | SELECT  -> (null : System.Object) 
  | REVERSE  -> (null : System.Object) 
  | RETURN  -> (null : System.Object) 
  | REQUEUE  -> (null : System.Object) 
  | RENAMES  -> (null : System.Object) 
  | REM  -> (null : System.Object) 
  | RECORD  -> (null : System.Object) 
  | RANGE  -> (null : System.Object) 
  | RAISE  -> (null : System.Object) 
  | PROTECTED  -> (null : System.Object) 
  | PROCEDURE  -> (null : System.Object) 
  | PRIVATE  -> (null : System.Object) 
  | PRAGMA  -> (null : System.Object) 
  | PACKAGE  -> (null : System.Object) 
  | OVERRIDING  -> (null : System.Object) 
  | OUT  -> (null : System.Object) 
  | OTHERS  -> (null : System.Object) 
  | OR  -> (null : System.Object) 
  | OF  -> (null : System.Object) 
  | NULL  -> (null : System.Object) 
  | NOT  -> (null : System.Object) 
  | NEW  -> (null : System.Object) 
  | MOD  -> (null : System.Object) 
  | LOOP  -> (null : System.Object) 
  | LIMITED  -> (null : System.Object) 
  | IS  -> (null : System.Object) 
  | INTERFACE  -> (null : System.Object) 
  | IN  -> (null : System.Object) 
  | IF  -> (null : System.Object) 
  | GOTO  -> (null : System.Object) 
  | GENERIC  -> (null : System.Object) 
  | FUNCTION  -> (null : System.Object) 
  | FOR  -> (null : System.Object) 
  | EXIT  -> (null : System.Object) 
  | EXCEPTION  -> (null : System.Object) 
  | ENTRY  -> (null : System.Object) 
  | END  -> (null : System.Object) 
  | ELSIF  -> (null : System.Object) 
  | ELSE  -> (null : System.Object) 
  | DO  -> (null : System.Object) 
  | DIGITS  -> (null : System.Object) 
  | DELTA  -> (null : System.Object) 
  | DELAY  -> (null : System.Object) 
  | DECLARE  -> (null : System.Object) 
  | CONSTANT  -> (null : System.Object) 
  | CASE  -> (null : System.Object) 
  | BODY  -> (null : System.Object) 
  | BEGIN  -> (null : System.Object) 
  | AT  -> (null : System.Object) 
  | ARRAY  -> (null : System.Object) 
  | AND  -> (null : System.Object) 
  | ALL  -> (null : System.Object) 
  | ALIASED  -> (null : System.Object) 
  | ACCESS  -> (null : System.Object) 
  | ACCEPT  -> (null : System.Object) 
  | ABSTRACT  -> (null : System.Object) 
  | ABS  -> (null : System.Object) 
  | ABORT  -> (null : System.Object) 
let _fsyacc_gotos = [| 0us; 65535us; 1us; 65535us; 0us; 1us; |]
let _fsyacc_sparseGotoTableRowOffsets = [|0us; 1us; |]
let _fsyacc_stateToProdIdxsTableElements = [| 1us; 0us; 1us; 0us; |]
let _fsyacc_stateToProdIdxsTableRowOffsets = [|0us; 2us; |]
let _fsyacc_action_rows = 2
let _fsyacc_actionTableElements = [|0us; 16385us; 0us; 49152us; |]
let _fsyacc_actionTableRowOffsets = [|0us; 1us; |]
let _fsyacc_reductionSymbolCounts = [|1us; 0us; |]
let _fsyacc_productionToNonTerminalTable = [|0us; 1us; |]
let _fsyacc_immediateActions = [|65535us; 49152us; |]
let _fsyacc_reductions ()  =    [| 
# 674 "Parser.fs"
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            let _1 = (let data = parseState.GetInput(1) in (Microsoft.FSharp.Core.Operators.unbox data : string)) in
            Microsoft.FSharp.Core.Operators.box
                (
                   (
                      raise (Microsoft.FSharp.Text.Parsing.Accept(Microsoft.FSharp.Core.Operators.box _1))
                   )
                 : '_startstart));
# 683 "Parser.fs"
        (fun (parseState : Microsoft.FSharp.Text.Parsing.IParseState) ->
            Microsoft.FSharp.Core.Operators.box
                (
                   (
# 118 "Parser.fsy"
                             "Nothing to see here" 
                   )
# 118 "Parser.fsy"
                 : string));
|]
# 694 "Parser.fs"
let tables () : Microsoft.FSharp.Text.Parsing.Tables<_> = 
  { reductions= _fsyacc_reductions ();
    endOfInputTag = _fsyacc_endOfInputTag;
    tagOfToken = tagOfToken;
    dataOfToken = _fsyacc_dataOfToken; 
    actionTableElements = _fsyacc_actionTableElements;
    actionTableRowOffsets = _fsyacc_actionTableRowOffsets;
    stateToProdIdxsTableElements = _fsyacc_stateToProdIdxsTableElements;
    stateToProdIdxsTableRowOffsets = _fsyacc_stateToProdIdxsTableRowOffsets;
    reductionSymbolCounts = _fsyacc_reductionSymbolCounts;
    immediateActions = _fsyacc_immediateActions;
    gotos = _fsyacc_gotos;
    sparseGotoTableRowOffsets = _fsyacc_sparseGotoTableRowOffsets;
    tagOfErrorTerminal = _fsyacc_tagOfErrorTerminal;
    parseError = (fun (ctxt:Microsoft.FSharp.Text.Parsing.ParseErrorContext<_>) -> 
                              match parse_error_rich with 
                              | Some f -> f ctxt
                              | None -> parse_error ctxt.Message);
    numTerminals = 105;
    productionToNonTerminalTable = _fsyacc_productionToNonTerminalTable  }
let engine lexer lexbuf startState = (tables ()).Interpret(lexer, lexbuf, startState)
let start lexer lexbuf : string =
    Microsoft.FSharp.Core.Operators.unbox ((tables ()).Interpret(lexer, lexbuf, 0))
